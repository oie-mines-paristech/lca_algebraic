<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>lca_algebraic.helpers API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lca_algebraic.helpers</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import re
import types
from collections import defaultdict
from copy import deepcopy
from itertools import chain

import pandas as pd
from IPython.core.display import display
from bw2data.backends.peewee.utils import dict_as_exchangedataset
from sympy import symbols

from .base_utils import *
from .base_utils import _getDb, _eprint, _actDesc, _getAmountOrFormula
from .params import *
from .params import _param_registry, _completeParamValues


BIOSPHERE3_DB_NAME = &#39;biosphere3&#39;

def ECOINVENT_DB_NAME() :
    &#34;&#34;&#34;Return the name of the ecoinvent DB&#34;&#34;&#34;
    for key in bw.databases.keys() :
        if &#39;ecoinvent&#39; in key :
            return key

    raise Exception(&#34;No ecoinvent DB found&#34;)

old_amount = symbols(&#34;old_amount&#34;)  # Can be used in epxression of amount for updateExchanges, in order to reference the previous value
NumOrExpression = Union[float, Basic]




class ActivityExtended(Activity):
    &#34;&#34;&#34;Improved API for activity : adding a few useful methods.
    Those methods are backported to #Activity in order to be directly available on all existing instances
    &#34;&#34;&#34;

    def getExchange(self, name=None, input=None, single=True):
        &#34;&#34;&#34;Get exchange by name or input

        Parameters
        ----------
        name : name of the exchange. Name can be suffixed with &#39;#LOCATION&#39; to distinguish several exchanges with same name. \
            It can also be suffised by &#39;*&#39; to match an exchange starting with this name. Location can be a negative match &#39;!&#39;
            Exampple : &#34;Wood*#!RoW&#34; matches any exchange with name  containing Wood, and location not &#34;RoW&#34;

        single :True if a single match is expected. Otherwize, a list of result is returned

        Returns
        -------
            Single exchange or list of exchanges (if _single is False or &#34;name&#34; contains a &#39;*&#39;)
            raise Exception if not matching exchange found
        &#34;&#34;&#34;

        def single_match(name, exch):

            # Name can be &#34;Elecricity#RER&#34;
            if &#34;#&#34; in name:
                name, loc = name.split(&#34;#&#34;)
                negative = False
                if loc.startswith(&#34;!&#34;):
                    negative = True
                    loc = loc[1:]
                act = getActByCode(*exch[&#39;input&#39;])

                if not &#39;location&#39; in act or (negative and act[&#39;location&#39;] == loc) or (
                        not negative and act[&#39;location&#39;] != loc):
                    return False

            if &#39;*&#39; in name:
                name = name.replace(&#39;*&#39;, &#39;&#39;)
                return name in exch[&#39;name&#39;]
            else:
                return name == exch[&#39;name&#39;]

        def match(exch):
            if name:
                if isinstance(name, list):
                    return any(single_match(iname, exch) for iname in name)
                else:
                    return single_match(name, exch)

            if input:
                return input == exch[&#39;input&#39;]

        exchs = list(exch for exch in self.exchangesNp() if match(exch))
        if len(exchs) == 0:
            raise Exception(&#34;Found no exchange matching name : %s&#34; % name)

        if single and len(exchs) != 1:
            raise Exception(&#34;Expected 1 exchange with name &#39;%s&#39; found %d&#34; % (name, len(exchs)))
        if single:
            return exchs[0]
        else:
            return exchs

    def setOutputAmount(self, amount):
        &#39;&#39;&#39;Set the amount for the single output exchange (1 by default)&#39;&#39;&#39;
        self.addExchanges({self: amount})

    def updateExchanges(self, updates: Dict[str, any] = dict()):
        &#34;&#34;&#34;Update existing exchanges, by name.

        Parameters
        ----------
        updates : Dict of &#34;&lt;exchange name&gt;&#34; =&gt; &lt;new value&gt;

            &lt;exchange name&gt; can be suffixed with &#39;#LOCATION&#39; to distinguish several exchanges with same name. \
            It can also be suffixed by &#39;*&#39; to match an exchange starting with this name. Location can be a negative match &#39;!&#39;
            Exampple : &#34;Wood*#!RoW&#34; matches any exchange with name  containing Wood, and location not &#34;RoW&#34;

            &lt;New Value&gt;  : either single value (float or SympPy expression) for updating only amount, or activity for updating only input,
            or dict of attributes, for updating both at once, or any other attribute.
            The amount can reference the symbol &#39;old_amount&#39; that will be replaced with the current amount of the exchange.
        &#34;&#34;&#34;

        # Update exchanges
        for name, attrs in updates.items():

            exchs = self.getExchange(name, single=not &#39;*&#39; in name)
            if not isinstance(exchs, list):
                exchs = [exchs]
            for exch in exchs:

                if attrs is None:
                    exch.delete()
                    exch.save()
                    continue

                # Single value ? =&gt; amount
                if not isinstance(attrs, dict):
                    if isinstance(attrs, Activity):
                        attrs = dict(input=attrs)
                    else:
                        attrs = dict(amount=attrs)

                if &#39;amount&#39; in attrs:
                    attrs.update(_amountToFormula(attrs[&#39;amount&#39;], exch[&#39;amount&#39;]))

                exch.update(attrs)
                exch.save()

                # We have a formula now ? =&gt; register it to parametrized exchange
                if &#39;formula&#39; in attrs:
                    bw.parameters.add_exchanges_to_group(DEFAULT_PARAM_GROUP, self)

    def deleteExchanges(self, name, single=True):
        &#39;&#39;&#39; Remove matching exchanges &#39;&#39;&#39;
        exchs = self.getExchange(name, single=single)
        if not isinstance(exchs, list):
            exchs = [exchs]
        if len(exchs) == 0:
            raise Exception(&#34;No exchange found for &#39;%s&#39;&#34; % name)
        for ex in exchs:
            ex.delete()
            ex.save()
        self.save()

    def substituteWithDefault(self, exchange_name: str, switch_act: Activity, paramSwitch: EnumParam, amount=None):

        &#34;&#34;&#34;Substitutes one exchange with a switch on other activities, or fallback to the current one as default (parameter set to None)
        For this purpose, we create a new exchange referencing the activity switch, and we multiply current activity by &#39;&lt;param_name&gt;_default&#39;,
        making it null as soon as one enum value is set.

        This is useful for changing electricty mix, leaving the default one if needed

        Parameters
        ----------
        act : Activity to update
        exchange_name : Name of the exchange to update
        switch_act : Activity to substitue as input
        amount : Amount of the input (uses previous amount by default)
        &#34;&#34;&#34;

        current_exch = self.getExchange(exchange_name)

        prev_amount = amount if amount else _getAmountOrFormula(current_exch)

        self.addExchanges({switch_act: prev_amount})
        self.updateExchanges({exchange_name: paramSwitch.symbol(None) * prev_amount})

    def addExchanges(self, exchanges: Dict[Activity, Union[NumOrExpression, dict]] = dict()):
        &#34;&#34;&#34;Add exchanges to an existing activity, with a compact syntax :

        Parameters
        ----------
        exchanges : Dict of activity =&gt; amount or activity =&gt; attributes_dict. \
            Amount being either a fixed value or Sympy expression (arithmetic expression of Sympy symbols)
        &#34;&#34;&#34;
        parametrized = False
        for sub_act, attrs in exchanges.items():

            if isinstance(attrs, dict):
                amount = attrs.pop(&#39;amount&#39;)
            else:
                amount = attrs
                attrs = dict()

            exch = self.new_exchange(
                input=sub_act.key,
                name=sub_act[&#39;name&#39;],
                unit=sub_act[&#39;unit&#39;] if &#39;unit&#39; in sub_act else None,
                type=&#39;production&#39; if self == sub_act else &#39;biosphere&#39; if sub_act[
                                                                             &#39;database&#39;] == BIOSPHERE3_DB_NAME else &#39;technosphere&#39;)

            exch.update(attrs)
            exch.update(_amountToFormula(amount))
            if &#39;formula&#39; in exch:
                parametrized = True

            exch.save()
        self.save()
        if parametrized:
            bw.parameters.add_exchanges_to_group(DEFAULT_PARAM_GROUP, self)

    def getAmount(self, *args, sum=False, **kargs):
        &#34;&#34;&#34;
        Get the amount of one or several exchanges, selected by name or input. See #getExchange()
        &#34;&#34;&#34;
        exchs = self.getExchange(*args, single=not sum, **kargs)
        if sum:
            res = 0
            if len(exchs) == 0:
                raise Exception(&#34;No exchange found&#34;)
            for exch in exchs:
                res += _getAmountOrFormula(exch)
            return res
        else:
            return _getAmountOrFormula(exchs)

    def exchangesNp(self):
        &#34;&#34;&#34; List of exchange, except production (output) one.&#34;&#34;&#34;
        for exch in self.exchanges():
            if exch[&#39;input&#39;] != exch[&#39;output&#39;]:
                yield exch


# Backport new methods to vanilla Activity class in order to benefit from it for all existing instances
for name, item in ActivityExtended.__dict__.items():
    if isinstance(item, types.FunctionType):
        setattr(Activity, name, item)


def _split_words(name):
    clean = re.sub(&#39;[^0-9a-zA-Z]+&#39;, &#39; &#39;, name)
    clean = re.sub(&#39; +&#39;, &#39; &#39;, clean)
    clean = clean.lower()

    return clean.split(&#39; &#39;)


def _build_index(db):
    res = defaultdict(set)
    for act in db:
        words = _split_words(act[&#39;name&#39;])
        for word in words:
            res[word].add(act)
    return res


# Index of activities per name, for fast search dict[db_name][activity_word] =&gt; list of activitites
db_index = dict()


def _get_indexed_db(db_name):
    if not db_name in db_index:
        db_index[db_name] = _build_index(_getDb(db_name))
    return db_index[db_name]


def _find_candidates(db_name, name):
    res = []
    index = _get_indexed_db(db_name)
    words = _split_words(name)
    for word in words:
        candidates = index[word]
        if len(res) == 0 or (0 &lt; len(candidates) &lt; len(res)):
            res = list(candidates)
    return res


def getActByCode(db_name, code):
    &#34;&#34;&#34; Get activity by code &#34;&#34;&#34;
    return _getDb(db_name).get(code)


def findActivity(name=None, loc=None, in_name=None, code=None, categories=None, category=None, db_name=None,
                 single=True, unit=None):
    &#34;&#34;&#34;
        Find single activity by name &amp; location
        Uses index for fast fetching
    &#34;&#34;&#34;

    if name and &#39;*&#39; in name:
        in_name = name.replace(&#34;*&#34;, &#34;&#34;)
        name = None

    def act_filter(act):
        if name and not name == act[&#39;name&#39;]:
            return False
        if in_name and not in_name in act[&#39;name&#39;]:
            return False
        if loc and not loc == act[&#39;location&#39;]:
            return False
        if unit and not unit == act[&#39;unit&#39;]:
            return False
        if category and not category in act[&#39;categories&#39;]:
            return False
        if categories and not tuple(categories) == act[&#39;categories&#39;]:
            return False
        return True

    if code:
        acts = [getActByCode(db_name, code)]
    else:
        search = name if name else in_name

        search = search.lower()
        search = search.replace(&#39;,&#39;, &#39; &#39;)
        search = re.sub(&#39;\w*[^a-zA-Z ]+\w*&#39;, &#39; &#39;, search)

        # print(search)

        # Find candidates via index
        # candidates = _find_candidates(db_name, name_key)
        candidates = _getDb(db_name).search(search, limit=200)

        # print(candidates)

        # Exact match
        acts = list(filter(act_filter, candidates))

    if single and len(acts) == 0:
        raise Exception(&#34;No activity found in &#39;%s&#39; with name &#39;%s&#39; and location &#39;%s&#39;&#34; % (db_name, name, loc))
    if single and len(acts) &gt; 1:
        raise Exception(&#34;Several activity found in &#39;%s&#39; with name &#39;%s&#39; and location &#39;%s&#39;:\n%s&#34; % (
            db_name, name, loc, str(acts)))
    if len(acts) == 1:
        return acts[0]
    else:
        return acts


def findBioAct(name=None, loc=None, **kwargs):
    &#34;&#34;&#34;Alias for findActivity(name, ... db_name=BIOSPHERE3_DB_NAME)
    &#34;&#34;&#34;
    return findActivity(name=name, loc=loc, db_name=BIOSPHERE3_DB_NAME, **kwargs)


def findTechAct(name=None, loc=None, **kwargs):
    &#34;&#34;&#34;Alias for findActivity(name, ... db_name=ECOINVENT_DB_NAME)
    &#34;&#34;&#34;
    return findActivity(name=name, loc=loc, db_name=ECOINVENT_DB_NAME(), **kwargs)


def _amountToFormula(amount: Union[float, str, Basic], currentAmount=None):
    &#34;&#34;&#34;Transform amount in exchange to either simple amount or formula&#34;&#34;&#34;
    res = dict()
    if isinstance(amount, Basic):

        if currentAmount != None:
            amount = amount.subs(old_amount, currentAmount)

        # Check the expression does not reference undefined params
        all_symbols = list([key for param in _param_registry().values() for key, val in param.expandParams().items()])
        for symbol in amount.free_symbols:
            if not str(symbol) in all_symbols:
                raise Exception(&#34;Symbol &#39;%s&#39; not found in params : %s&#34; % (symbol, all_symbols))

        res[&#39;formula&#39;] = str(amount)
        res[&#39;amount&#39;] = 0
    elif isinstance(amount, float) or isinstance(amount, int):
        res[&#39;amount&#39;] = amount
    else:
        raise Exception(
            &#34;Amount should be either a constant number or a Sympy expression (expression of ParamDef). Was : %s&#34; % type(
                amount))
    return res


def _newAct(db_name, code):
    db = _getDb(db_name)
    # Already present : delete it ?
    for act in db:
        if act[&#39;code&#39;] == code:
            _eprint(&#34;Activity &#39;%s&#39; was already in &#39;%s&#39;. Overwriting it&#34; % (code, db_name))
            act.delete()

    return db.new_activity(code)


def newActivity(db_name, name, unit,
                exchanges: Dict[Activity, Union[float, str]] = dict(),
                code=None,
                **argv):
    &#34;&#34;&#34;Creates a new activity

    Parameters
    ----------
    name : Name ofthe new activity
    db_name : Destination DB : ACV DB by default
    exchanges : Dict of activity =&gt; amount. If amount is a string, is it considered as a formula with parameters
    argv : extra params passed as properties of the new activity
    &#34;&#34;&#34;
    act = _newAct(db_name, code if code else name)
    act[&#39;name&#39;] = name
    act[&#39;type&#39;] = &#39;process&#39;
    act[&#39;unit&#39;] = unit
    act.update(argv)

    # Add exchanges
    act.addExchanges(exchanges)

    return act


def copyActivity(db_name, activity: ActivityExtended, code=None, withExchanges=True, **kwargs) -&gt; ActivityExtended:
    &#34;&#34;&#34;Copy activity into a new DB&#34;&#34;&#34;

    res = _newAct(db_name, code)

    for key, value in activity.items():
        if key not in [&#39;database&#39;, &#39;code&#39;]:
            res[key] = value
    for k, v in kwargs.items():
        res._data[k] = v
    res._data[u&#39;code&#39;] = code
    res[&#39;name&#39;] = code
    res.save()

    if withExchanges:
        for exc in activity.exchanges():
            data = deepcopy(exc._data)
            data[&#39;output&#39;] = res.key
            # Change `input` for production exchanges
            if exc[&#39;input&#39;] == exc[&#39;output&#39;]:
                data[&#39;input&#39;] = res.key
            ExchangeDataset.create(**dict_as_exchangedataset(data))

    return res


def newSwitchAct(dbname, name, paramDef: ParamDef, acts_dict: Dict[str, Activity]):
    &#34;&#34;&#34;Create a new parametrized, virtual activity, made of a map of other activities, controlled by an enum parameter.
    This enables to implement a &#34;Switch&#34; with brightway parameters
    Internally, this will create a linear sum of other activities controlled by &lt;param_name&gt;_&lt;enum_value&gt; : 0 or 1

    By default, all activities have associated amount of 1.
    You can provide other amounts by providing a tuple of (activity, amount).

    Parameters
    ----------
    dbname: name of the target DB
    name: Name of the new activity
    paramDef : parameter definition of type enum
    acts_dict : dict of &#34;enumValue&#34; =&gt; activity or &#34;enumValue&#34; =&gt; (activity, amount)

    Examples
    --------

    &gt;&gt;&gt; newSwitchAct(MYDB, &#34;switchAct&#34;, switchParam, {
    &gt;&gt;&gt;    &#34;val1&#34; : act1 # Amount is 1
    &gt;&gt;&gt;    &#34;val2&#34; : (act2, 0.4) # Different amount
    &gt;&gt;&gt;    &#34;val3&#34; : (act3, b + 6) # Amount with formula
    &gt;&gt;&gt; }
    &#34;&#34;&#34;

    # Transform map of enum values to corresponding formulas &lt;param_name&gt;_&lt;enum_value&gt;
    exch = dict()
    for key, act in acts_dict.items() :
        amount = 1
        if type(act) == list or type(act) == tuple :
            act, amount = act
        exch[act] = amount * paramDef.symbol(key)

    res = newActivity(
        dbname,
        name,
        unit=list(acts_dict.values())[0][&#39;unit&#39;],
        exchanges=exch)

    return res


def printAct(*activities, **params):
    &#34;&#34;&#34;
    Print activities and their exchanges.
    If parameter values are provided, formulas will be evaluated accordingly
    &#34;&#34;&#34;
    tables = []
    names = []

    for act in activities:
        df = pd.DataFrame(index=[&#39;input&#39;, &#39;amount&#39;, &#39;unit&#39;, &#39;type&#39;])
        data = dict()
        for (i, exc) in enumerate(act.exchanges()):
            input = bw.get_activity(exc.input.key)
            amount = _getAmountOrFormula(exc)

            # Params provided ? Evaluate formulas
            if len(params) &gt; 0 and isinstance(amount, Basic):
                new_params = [(name, value) for name, value in _completeParamValues(params).items()]
                amount = amount.subs(new_params)

            name = exc[&#39;name&#39;]
            if &#39;location&#39; in input and input[&#39;location&#39;] != &#34;GLO&#34;:
                name += &#34;#%s&#34; % input[&#39;location&#39;]
            if exc.input.key[0] not in [BIOSPHERE3_DB_NAME, ECOINVENT_DB_NAME()]:
                name += &#34; {user-db}&#34;

            iname = name
            i = 1
            while iname in data:
                iname = &#34;%s#%d&#34; % (name, i)
                i += 1

            data[iname] = [str(input), amount, exc.unit, exc[&#39;type&#39;]]

        for key, values in data.items():
            df[key] = values

        tables.append(df.T)
        names.append(_actDesc(act))

    full = pd.concat(tables, axis=1, keys=names, sort=True)

    if len(activities) == 2:
        yellow = &#34;background-color:yellow&#34;
        iamount1 = full.columns.get_loc((names[0], &#34;amount&#34;))
        iamount2 = full.columns.get_loc((names[1], &#34;amount&#34;))
        iact1 = full.columns.get_loc((names[0], &#34;input&#34;))
        iact2 = full.columns.get_loc((names[1], &#34;input&#34;))

        def same_amount(row):
            res = [&#34;&#34;] * len(row)

            if row[iamount1] != row[iamount2]:
                res[iamount1] = yellow
                res[iamount2] = yellow
            if row[iact1] != row[iact2]:
                res[iact1] = yellow
                res[iact2] = yellow
            return res

        full = full.style.apply(same_amount, axis=1)

    display(full)


def newInterpolatedAct(dbname: str, name: str, act1: ActivityExtended, act2: ActivityExtended, x1, x2, x, alpha1=1,
                       alpha2=1, **kwargs):
    &#34;&#34;&#34;Creates a new activity made of interpolation of two similar activities.
    For each exchange :
    amount = alpha1 * a1 + (x - X1) * (alpha2 * a2 - alpha1 * a1) / (x2 - x1)

    Parameters
    ----------
    name : Name of new activity
    act1 : Activity 1
    act2 : Activity 2
    x1 : X for act1
    x2 : X for act 2
    x : Should be a parameter symbol
    alpha1 : Ratio for act1 (Default value = 1)
    alpha2 : Ratio for act2 (Default value = 1)
    kwargs : Any other param will be added as attributes of new activity
    &#34;&#34;&#34;
    res = copyActivity(dbname, act1, name, withExchanges=False, **kwargs)

    exch1_by_input = dict({exch[&#39;input&#39;]: exch for exch in act1.exchangesNp()})
    exch2_by_input = dict({exch[&#39;input&#39;]: exch for exch in act2.exchangesNp()})

    inputs = set(chain(exch1_by_input.keys(), exch2_by_input.keys()))

    for input in inputs:

        exch1 = exch1_by_input.get(input)
        exch2 = exch2_by_input.get(input)
        exch = exch1 if exch1 else exch2

        amount1 = exch1[&#39;amount&#39;] if exch1 else 0
        amount2 = exch2[&#39;amount&#39;] if exch2 else 0

        if exch1 and exch2 and exch1[&#39;name&#39;] != exch2[&#39;name&#39;]:
            raise Exception(&#34;Input %s refer two different names : %s, %s&#34; % (input, exch1[&#39;name&#39;], exch2[&#39;name&#39;]))

        amount = interpolate(x, x1, x2, amount1 * alpha1, amount2 * alpha2)
        act = getActByCode(*input)
        res.addExchanges({act: dict(amount=amount, name=exch[&#39;name&#39;])})
    return res</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="lca_algebraic.helpers.ECOINVENT_DB_NAME"><code class="name flex">
<span>def <span class="ident">ECOINVENT_DB_NAME</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the name of the ecoinvent DB</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ECOINVENT_DB_NAME() :
    &#34;&#34;&#34;Return the name of the ecoinvent DB&#34;&#34;&#34;
    for key in bw.databases.keys() :
        if &#39;ecoinvent&#39; in key :
            return key

    raise Exception(&#34;No ecoinvent DB found&#34;)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.helpers.copyActivity"><code class="name flex">
<span>def <span class="ident">copyActivity</span></span>(<span>db_name, activity, code=None, withExchanges=True, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Copy activity into a new DB</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copyActivity(db_name, activity: ActivityExtended, code=None, withExchanges=True, **kwargs) -&gt; ActivityExtended:
    &#34;&#34;&#34;Copy activity into a new DB&#34;&#34;&#34;

    res = _newAct(db_name, code)

    for key, value in activity.items():
        if key not in [&#39;database&#39;, &#39;code&#39;]:
            res[key] = value
    for k, v in kwargs.items():
        res._data[k] = v
    res._data[u&#39;code&#39;] = code
    res[&#39;name&#39;] = code
    res.save()

    if withExchanges:
        for exc in activity.exchanges():
            data = deepcopy(exc._data)
            data[&#39;output&#39;] = res.key
            # Change `input` for production exchanges
            if exc[&#39;input&#39;] == exc[&#39;output&#39;]:
                data[&#39;input&#39;] = res.key
            ExchangeDataset.create(**dict_as_exchangedataset(data))

    return res</code></pre>
</details>
</dd>
<dt id="lca_algebraic.helpers.findActivity"><code class="name flex">
<span>def <span class="ident">findActivity</span></span>(<span>name=None, loc=None, in_name=None, code=None, categories=None, category=None, db_name=None, single=True, unit=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Find single activity by name &amp; location
Uses index for fast fetching</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findActivity(name=None, loc=None, in_name=None, code=None, categories=None, category=None, db_name=None,
                 single=True, unit=None):
    &#34;&#34;&#34;
        Find single activity by name &amp; location
        Uses index for fast fetching
    &#34;&#34;&#34;

    if name and &#39;*&#39; in name:
        in_name = name.replace(&#34;*&#34;, &#34;&#34;)
        name = None

    def act_filter(act):
        if name and not name == act[&#39;name&#39;]:
            return False
        if in_name and not in_name in act[&#39;name&#39;]:
            return False
        if loc and not loc == act[&#39;location&#39;]:
            return False
        if unit and not unit == act[&#39;unit&#39;]:
            return False
        if category and not category in act[&#39;categories&#39;]:
            return False
        if categories and not tuple(categories) == act[&#39;categories&#39;]:
            return False
        return True

    if code:
        acts = [getActByCode(db_name, code)]
    else:
        search = name if name else in_name

        search = search.lower()
        search = search.replace(&#39;,&#39;, &#39; &#39;)
        search = re.sub(&#39;\w*[^a-zA-Z ]+\w*&#39;, &#39; &#39;, search)

        # print(search)

        # Find candidates via index
        # candidates = _find_candidates(db_name, name_key)
        candidates = _getDb(db_name).search(search, limit=200)

        # print(candidates)

        # Exact match
        acts = list(filter(act_filter, candidates))

    if single and len(acts) == 0:
        raise Exception(&#34;No activity found in &#39;%s&#39; with name &#39;%s&#39; and location &#39;%s&#39;&#34; % (db_name, name, loc))
    if single and len(acts) &gt; 1:
        raise Exception(&#34;Several activity found in &#39;%s&#39; with name &#39;%s&#39; and location &#39;%s&#39;:\n%s&#34; % (
            db_name, name, loc, str(acts)))
    if len(acts) == 1:
        return acts[0]
    else:
        return acts</code></pre>
</details>
</dd>
<dt id="lca_algebraic.helpers.findBioAct"><code class="name flex">
<span>def <span class="ident">findBioAct</span></span>(<span>name=None, loc=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Alias for findActivity(name, &hellip; db_name=BIOSPHERE3_DB_NAME)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findBioAct(name=None, loc=None, **kwargs):
    &#34;&#34;&#34;Alias for findActivity(name, ... db_name=BIOSPHERE3_DB_NAME)
    &#34;&#34;&#34;
    return findActivity(name=name, loc=loc, db_name=BIOSPHERE3_DB_NAME, **kwargs)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.helpers.findTechAct"><code class="name flex">
<span>def <span class="ident">findTechAct</span></span>(<span>name=None, loc=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Alias for findActivity(name, &hellip; db_name=ECOINVENT_DB_NAME)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findTechAct(name=None, loc=None, **kwargs):
    &#34;&#34;&#34;Alias for findActivity(name, ... db_name=ECOINVENT_DB_NAME)
    &#34;&#34;&#34;
    return findActivity(name=name, loc=loc, db_name=ECOINVENT_DB_NAME(), **kwargs)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.helpers.getActByCode"><code class="name flex">
<span>def <span class="ident">getActByCode</span></span>(<span>db_name, code)</span>
</code></dt>
<dd>
<section class="desc"><p>Get activity by code</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getActByCode(db_name, code):
    &#34;&#34;&#34; Get activity by code &#34;&#34;&#34;
    return _getDb(db_name).get(code)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.helpers.newActivity"><code class="name flex">
<span>def <span class="ident">newActivity</span></span>(<span>db_name, name, unit, exchanges={}, code=None, **argv)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a new activity</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>Name</code> <code>ofthe</code> <code>new</code> <code>activity</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>db_name</code></strong> :&ensp;<code>Destination</code> <code>DB</code> : <code>ACV</code> <code>DB</code> <code>by</code> default</dt>
<dd>&nbsp;</dd>
<dt><strong><code>exchanges</code></strong> :&ensp;<code>Dict</code> of <code>activity</code> =&gt; <code>amount.</code> <code>If</code> <code>amount</code> <code>is</code> <code>a</code> <code>string</code>, <code>is</code> <code>it</code> <code>considered</code> <code>as</code> <code>a</code> <code>formula</code> <code>with</code> <code>parameters</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>argv</code></strong> :&ensp;<code>extra</code> <code>params</code> <code>passed</code> <code>as</code> <code>properties</code> of <code>the</code> <code>new</code> <code>activity</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newActivity(db_name, name, unit,
                exchanges: Dict[Activity, Union[float, str]] = dict(),
                code=None,
                **argv):
    &#34;&#34;&#34;Creates a new activity

    Parameters
    ----------
    name : Name ofthe new activity
    db_name : Destination DB : ACV DB by default
    exchanges : Dict of activity =&gt; amount. If amount is a string, is it considered as a formula with parameters
    argv : extra params passed as properties of the new activity
    &#34;&#34;&#34;
    act = _newAct(db_name, code if code else name)
    act[&#39;name&#39;] = name
    act[&#39;type&#39;] = &#39;process&#39;
    act[&#39;unit&#39;] = unit
    act.update(argv)

    # Add exchanges
    act.addExchanges(exchanges)

    return act</code></pre>
</details>
</dd>
<dt id="lca_algebraic.helpers.newInterpolatedAct"><code class="name flex">
<span>def <span class="ident">newInterpolatedAct</span></span>(<span>dbname, name, act1, act2, x1, x2, x, alpha1=1, alpha2=1, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a new activity made of interpolation of two similar activities.
For each exchange :
amount = alpha1 * a1 + (x - X1) * (alpha2 * a2 - alpha1 * a1) / (x2 - x1)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>Name</code> of <code>new</code> <code>activity</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>act1</code></strong> :&ensp;<code>Activity</code> <code>1</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>act2</code></strong> :&ensp;<code>Activity</code> <code>2</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>x1</code></strong> :&ensp;<code>X</code> <code>for</code> <code>act1</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>x2</code></strong> :&ensp;<code>X</code> <code>for</code> <code>act</code> <code>2</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>Should</code> <code>be</code> <code>a</code> <code>parameter</code> <code>symbol</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>alpha1</code></strong> :&ensp;<code>Ratio</code> <code>for</code> <code>act1</code> (<code>Default</code> <code>value</code> = <code>1</code>)</dt>
<dd>&nbsp;</dd>
<dt><strong><code>alpha2</code></strong> :&ensp;<code>Ratio</code> <code>for</code> <code>act2</code> (<code>Default</code> <code>value</code> = <code>1</code>)</dt>
<dd>&nbsp;</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>Any</code> <code>other</code> <code>param</code> <code>will</code> <code>be</code> <code>added</code> <code>as</code> <code>attributes</code> of <code>new</code> <code>activity</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newInterpolatedAct(dbname: str, name: str, act1: ActivityExtended, act2: ActivityExtended, x1, x2, x, alpha1=1,
                       alpha2=1, **kwargs):
    &#34;&#34;&#34;Creates a new activity made of interpolation of two similar activities.
    For each exchange :
    amount = alpha1 * a1 + (x - X1) * (alpha2 * a2 - alpha1 * a1) / (x2 - x1)

    Parameters
    ----------
    name : Name of new activity
    act1 : Activity 1
    act2 : Activity 2
    x1 : X for act1
    x2 : X for act 2
    x : Should be a parameter symbol
    alpha1 : Ratio for act1 (Default value = 1)
    alpha2 : Ratio for act2 (Default value = 1)
    kwargs : Any other param will be added as attributes of new activity
    &#34;&#34;&#34;
    res = copyActivity(dbname, act1, name, withExchanges=False, **kwargs)

    exch1_by_input = dict({exch[&#39;input&#39;]: exch for exch in act1.exchangesNp()})
    exch2_by_input = dict({exch[&#39;input&#39;]: exch for exch in act2.exchangesNp()})

    inputs = set(chain(exch1_by_input.keys(), exch2_by_input.keys()))

    for input in inputs:

        exch1 = exch1_by_input.get(input)
        exch2 = exch2_by_input.get(input)
        exch = exch1 if exch1 else exch2

        amount1 = exch1[&#39;amount&#39;] if exch1 else 0
        amount2 = exch2[&#39;amount&#39;] if exch2 else 0

        if exch1 and exch2 and exch1[&#39;name&#39;] != exch2[&#39;name&#39;]:
            raise Exception(&#34;Input %s refer two different names : %s, %s&#34; % (input, exch1[&#39;name&#39;], exch2[&#39;name&#39;]))

        amount = interpolate(x, x1, x2, amount1 * alpha1, amount2 * alpha2)
        act = getActByCode(*input)
        res.addExchanges({act: dict(amount=amount, name=exch[&#39;name&#39;])})
    return res</code></pre>
</details>
</dd>
<dt id="lca_algebraic.helpers.newSwitchAct"><code class="name flex">
<span>def <span class="ident">newSwitchAct</span></span>(<span>dbname, name, paramDef, acts_dict)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a new parametrized, virtual activity, made of a map of other activities, controlled by an enum parameter.
This enables to implement a "Switch" with brightway parameters
Internally, this will create a linear sum of other activities controlled by <param_name>_<enum_value> : 0 or 1</p>
<p>By default, all activities have associated amount of 1.
You can provide other amounts by providing a tuple of (activity, amount).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dbname</code></strong> :&ensp;<code>name</code> of <code>the</code> <code>target</code> <code>DB</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>Name</code> of <code>the</code> <code>new</code> <code>activity</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>paramDef</code></strong> :&ensp;<code>parameter</code> <code>definition</code> of <code>type</code> <code>enum</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>acts_dict</code></strong> :&ensp;<code>dict</code> of <code>"enumValue"</code> =&gt; <code>activity</code> or <code>"enumValue"</code> =&gt; (<code>activity</code>, <code>amount</code>)</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; newSwitchAct(MYDB, "switchAct", switchParam, {
&gt;&gt;&gt;    "val1" : act1 # Amount is 1
&gt;&gt;&gt;    "val2" : (act2, 0.4) # Different amount
&gt;&gt;&gt;    "val3" : (act3, b + 6) # Amount with formula
&gt;&gt;&gt; }
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newSwitchAct(dbname, name, paramDef: ParamDef, acts_dict: Dict[str, Activity]):
    &#34;&#34;&#34;Create a new parametrized, virtual activity, made of a map of other activities, controlled by an enum parameter.
    This enables to implement a &#34;Switch&#34; with brightway parameters
    Internally, this will create a linear sum of other activities controlled by &lt;param_name&gt;_&lt;enum_value&gt; : 0 or 1

    By default, all activities have associated amount of 1.
    You can provide other amounts by providing a tuple of (activity, amount).

    Parameters
    ----------
    dbname: name of the target DB
    name: Name of the new activity
    paramDef : parameter definition of type enum
    acts_dict : dict of &#34;enumValue&#34; =&gt; activity or &#34;enumValue&#34; =&gt; (activity, amount)

    Examples
    --------

    &gt;&gt;&gt; newSwitchAct(MYDB, &#34;switchAct&#34;, switchParam, {
    &gt;&gt;&gt;    &#34;val1&#34; : act1 # Amount is 1
    &gt;&gt;&gt;    &#34;val2&#34; : (act2, 0.4) # Different amount
    &gt;&gt;&gt;    &#34;val3&#34; : (act3, b + 6) # Amount with formula
    &gt;&gt;&gt; }
    &#34;&#34;&#34;

    # Transform map of enum values to corresponding formulas &lt;param_name&gt;_&lt;enum_value&gt;
    exch = dict()
    for key, act in acts_dict.items() :
        amount = 1
        if type(act) == list or type(act) == tuple :
            act, amount = act
        exch[act] = amount * paramDef.symbol(key)

    res = newActivity(
        dbname,
        name,
        unit=list(acts_dict.values())[0][&#39;unit&#39;],
        exchanges=exch)

    return res</code></pre>
</details>
</dd>
<dt id="lca_algebraic.helpers.printAct"><code class="name flex">
<span>def <span class="ident">printAct</span></span>(<span>*activities, **params)</span>
</code></dt>
<dd>
<section class="desc"><p>Print activities and their exchanges.
If parameter values are provided, formulas will be evaluated accordingly</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printAct(*activities, **params):
    &#34;&#34;&#34;
    Print activities and their exchanges.
    If parameter values are provided, formulas will be evaluated accordingly
    &#34;&#34;&#34;
    tables = []
    names = []

    for act in activities:
        df = pd.DataFrame(index=[&#39;input&#39;, &#39;amount&#39;, &#39;unit&#39;, &#39;type&#39;])
        data = dict()
        for (i, exc) in enumerate(act.exchanges()):
            input = bw.get_activity(exc.input.key)
            amount = _getAmountOrFormula(exc)

            # Params provided ? Evaluate formulas
            if len(params) &gt; 0 and isinstance(amount, Basic):
                new_params = [(name, value) for name, value in _completeParamValues(params).items()]
                amount = amount.subs(new_params)

            name = exc[&#39;name&#39;]
            if &#39;location&#39; in input and input[&#39;location&#39;] != &#34;GLO&#34;:
                name += &#34;#%s&#34; % input[&#39;location&#39;]
            if exc.input.key[0] not in [BIOSPHERE3_DB_NAME, ECOINVENT_DB_NAME()]:
                name += &#34; {user-db}&#34;

            iname = name
            i = 1
            while iname in data:
                iname = &#34;%s#%d&#34; % (name, i)
                i += 1

            data[iname] = [str(input), amount, exc.unit, exc[&#39;type&#39;]]

        for key, values in data.items():
            df[key] = values

        tables.append(df.T)
        names.append(_actDesc(act))

    full = pd.concat(tables, axis=1, keys=names, sort=True)

    if len(activities) == 2:
        yellow = &#34;background-color:yellow&#34;
        iamount1 = full.columns.get_loc((names[0], &#34;amount&#34;))
        iamount2 = full.columns.get_loc((names[1], &#34;amount&#34;))
        iact1 = full.columns.get_loc((names[0], &#34;input&#34;))
        iact2 = full.columns.get_loc((names[1], &#34;input&#34;))

        def same_amount(row):
            res = [&#34;&#34;] * len(row)

            if row[iamount1] != row[iamount2]:
                res[iamount1] = yellow
                res[iamount2] = yellow
            if row[iact1] != row[iact2]:
                res[iact1] = yellow
                res[iact2] = yellow
            return res

        full = full.style.apply(same_amount, axis=1)

    display(full)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lca_algebraic.helpers.ActivityExtended"><code class="flex name class">
<span>class <span class="ident">ActivityExtended</span></span>
<span>(</span><span>document=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Improved API for activity : adding a few useful methods.
Those methods are backported to #Activity in order to be directly available on all existing instances</p>
<p>Create an <code>Activity</code> proxy object.</p>
<p>If this is a new activity, can pass <code>kwargs</code>.</p>
<p>If the activity exists in the database, <code>document</code> should be an <code>ActivityDataset</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ActivityExtended(Activity):
    &#34;&#34;&#34;Improved API for activity : adding a few useful methods.
    Those methods are backported to #Activity in order to be directly available on all existing instances
    &#34;&#34;&#34;

    def getExchange(self, name=None, input=None, single=True):
        &#34;&#34;&#34;Get exchange by name or input

        Parameters
        ----------
        name : name of the exchange. Name can be suffixed with &#39;#LOCATION&#39; to distinguish several exchanges with same name. \
            It can also be suffised by &#39;*&#39; to match an exchange starting with this name. Location can be a negative match &#39;!&#39;
            Exampple : &#34;Wood*#!RoW&#34; matches any exchange with name  containing Wood, and location not &#34;RoW&#34;

        single :True if a single match is expected. Otherwize, a list of result is returned

        Returns
        -------
            Single exchange or list of exchanges (if _single is False or &#34;name&#34; contains a &#39;*&#39;)
            raise Exception if not matching exchange found
        &#34;&#34;&#34;

        def single_match(name, exch):

            # Name can be &#34;Elecricity#RER&#34;
            if &#34;#&#34; in name:
                name, loc = name.split(&#34;#&#34;)
                negative = False
                if loc.startswith(&#34;!&#34;):
                    negative = True
                    loc = loc[1:]
                act = getActByCode(*exch[&#39;input&#39;])

                if not &#39;location&#39; in act or (negative and act[&#39;location&#39;] == loc) or (
                        not negative and act[&#39;location&#39;] != loc):
                    return False

            if &#39;*&#39; in name:
                name = name.replace(&#39;*&#39;, &#39;&#39;)
                return name in exch[&#39;name&#39;]
            else:
                return name == exch[&#39;name&#39;]

        def match(exch):
            if name:
                if isinstance(name, list):
                    return any(single_match(iname, exch) for iname in name)
                else:
                    return single_match(name, exch)

            if input:
                return input == exch[&#39;input&#39;]

        exchs = list(exch for exch in self.exchangesNp() if match(exch))
        if len(exchs) == 0:
            raise Exception(&#34;Found no exchange matching name : %s&#34; % name)

        if single and len(exchs) != 1:
            raise Exception(&#34;Expected 1 exchange with name &#39;%s&#39; found %d&#34; % (name, len(exchs)))
        if single:
            return exchs[0]
        else:
            return exchs

    def setOutputAmount(self, amount):
        &#39;&#39;&#39;Set the amount for the single output exchange (1 by default)&#39;&#39;&#39;
        self.addExchanges({self: amount})

    def updateExchanges(self, updates: Dict[str, any] = dict()):
        &#34;&#34;&#34;Update existing exchanges, by name.

        Parameters
        ----------
        updates : Dict of &#34;&lt;exchange name&gt;&#34; =&gt; &lt;new value&gt;

            &lt;exchange name&gt; can be suffixed with &#39;#LOCATION&#39; to distinguish several exchanges with same name. \
            It can also be suffixed by &#39;*&#39; to match an exchange starting with this name. Location can be a negative match &#39;!&#39;
            Exampple : &#34;Wood*#!RoW&#34; matches any exchange with name  containing Wood, and location not &#34;RoW&#34;

            &lt;New Value&gt;  : either single value (float or SympPy expression) for updating only amount, or activity for updating only input,
            or dict of attributes, for updating both at once, or any other attribute.
            The amount can reference the symbol &#39;old_amount&#39; that will be replaced with the current amount of the exchange.
        &#34;&#34;&#34;

        # Update exchanges
        for name, attrs in updates.items():

            exchs = self.getExchange(name, single=not &#39;*&#39; in name)
            if not isinstance(exchs, list):
                exchs = [exchs]
            for exch in exchs:

                if attrs is None:
                    exch.delete()
                    exch.save()
                    continue

                # Single value ? =&gt; amount
                if not isinstance(attrs, dict):
                    if isinstance(attrs, Activity):
                        attrs = dict(input=attrs)
                    else:
                        attrs = dict(amount=attrs)

                if &#39;amount&#39; in attrs:
                    attrs.update(_amountToFormula(attrs[&#39;amount&#39;], exch[&#39;amount&#39;]))

                exch.update(attrs)
                exch.save()

                # We have a formula now ? =&gt; register it to parametrized exchange
                if &#39;formula&#39; in attrs:
                    bw.parameters.add_exchanges_to_group(DEFAULT_PARAM_GROUP, self)

    def deleteExchanges(self, name, single=True):
        &#39;&#39;&#39; Remove matching exchanges &#39;&#39;&#39;
        exchs = self.getExchange(name, single=single)
        if not isinstance(exchs, list):
            exchs = [exchs]
        if len(exchs) == 0:
            raise Exception(&#34;No exchange found for &#39;%s&#39;&#34; % name)
        for ex in exchs:
            ex.delete()
            ex.save()
        self.save()

    def substituteWithDefault(self, exchange_name: str, switch_act: Activity, paramSwitch: EnumParam, amount=None):

        &#34;&#34;&#34;Substitutes one exchange with a switch on other activities, or fallback to the current one as default (parameter set to None)
        For this purpose, we create a new exchange referencing the activity switch, and we multiply current activity by &#39;&lt;param_name&gt;_default&#39;,
        making it null as soon as one enum value is set.

        This is useful for changing electricty mix, leaving the default one if needed

        Parameters
        ----------
        act : Activity to update
        exchange_name : Name of the exchange to update
        switch_act : Activity to substitue as input
        amount : Amount of the input (uses previous amount by default)
        &#34;&#34;&#34;

        current_exch = self.getExchange(exchange_name)

        prev_amount = amount if amount else _getAmountOrFormula(current_exch)

        self.addExchanges({switch_act: prev_amount})
        self.updateExchanges({exchange_name: paramSwitch.symbol(None) * prev_amount})

    def addExchanges(self, exchanges: Dict[Activity, Union[NumOrExpression, dict]] = dict()):
        &#34;&#34;&#34;Add exchanges to an existing activity, with a compact syntax :

        Parameters
        ----------
        exchanges : Dict of activity =&gt; amount or activity =&gt; attributes_dict. \
            Amount being either a fixed value or Sympy expression (arithmetic expression of Sympy symbols)
        &#34;&#34;&#34;
        parametrized = False
        for sub_act, attrs in exchanges.items():

            if isinstance(attrs, dict):
                amount = attrs.pop(&#39;amount&#39;)
            else:
                amount = attrs
                attrs = dict()

            exch = self.new_exchange(
                input=sub_act.key,
                name=sub_act[&#39;name&#39;],
                unit=sub_act[&#39;unit&#39;] if &#39;unit&#39; in sub_act else None,
                type=&#39;production&#39; if self == sub_act else &#39;biosphere&#39; if sub_act[
                                                                             &#39;database&#39;] == BIOSPHERE3_DB_NAME else &#39;technosphere&#39;)

            exch.update(attrs)
            exch.update(_amountToFormula(amount))
            if &#39;formula&#39; in exch:
                parametrized = True

            exch.save()
        self.save()
        if parametrized:
            bw.parameters.add_exchanges_to_group(DEFAULT_PARAM_GROUP, self)

    def getAmount(self, *args, sum=False, **kargs):
        &#34;&#34;&#34;
        Get the amount of one or several exchanges, selected by name or input. See #getExchange()
        &#34;&#34;&#34;
        exchs = self.getExchange(*args, single=not sum, **kargs)
        if sum:
            res = 0
            if len(exchs) == 0:
                raise Exception(&#34;No exchange found&#34;)
            for exch in exchs:
                res += _getAmountOrFormula(exch)
            return res
        else:
            return _getAmountOrFormula(exchs)

    def exchangesNp(self):
        &#34;&#34;&#34; List of exchange, except production (output) one.&#34;&#34;&#34;
        for exch in self.exchanges():
            if exch[&#39;input&#39;] != exch[&#39;output&#39;]:
                yield exch</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>bw2data.backends.peewee.proxies.Activity</li>
<li>bw2data.proxies.ActivityProxyBase</li>
<li>bw2data.proxies.ProxyBase</li>
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lca_algebraic.helpers.ActivityExtended.addExchanges"><code class="name flex">
<span>def <span class="ident">addExchanges</span></span>(<span>self, exchanges={})</span>
</code></dt>
<dd>
<section class="desc"><p>Add exchanges to an existing activity, with a compact syntax :</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>exchanges</code></strong> :&ensp;<code>Dict</code> of <code>activity</code> =&gt; <code>amount</code> or <code>activity</code> =&gt; <code>attributes_dict.</code>
<code>Amount</code> <code>being</code> <code>either</code> <code>a</code> <code>fixed</code> <code>value</code> or <code>Sympy</code> <code>expression</code> (<code>arithmetic</code> <code>expression</code> of <code>Sympy</code> <code>symbols</code>)</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addExchanges(self, exchanges: Dict[Activity, Union[NumOrExpression, dict]] = dict()):
    &#34;&#34;&#34;Add exchanges to an existing activity, with a compact syntax :

    Parameters
    ----------
    exchanges : Dict of activity =&gt; amount or activity =&gt; attributes_dict. \
        Amount being either a fixed value or Sympy expression (arithmetic expression of Sympy symbols)
    &#34;&#34;&#34;
    parametrized = False
    for sub_act, attrs in exchanges.items():

        if isinstance(attrs, dict):
            amount = attrs.pop(&#39;amount&#39;)
        else:
            amount = attrs
            attrs = dict()

        exch = self.new_exchange(
            input=sub_act.key,
            name=sub_act[&#39;name&#39;],
            unit=sub_act[&#39;unit&#39;] if &#39;unit&#39; in sub_act else None,
            type=&#39;production&#39; if self == sub_act else &#39;biosphere&#39; if sub_act[
                                                                         &#39;database&#39;] == BIOSPHERE3_DB_NAME else &#39;technosphere&#39;)

        exch.update(attrs)
        exch.update(_amountToFormula(amount))
        if &#39;formula&#39; in exch:
            parametrized = True

        exch.save()
    self.save()
    if parametrized:
        bw.parameters.add_exchanges_to_group(DEFAULT_PARAM_GROUP, self)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.helpers.ActivityExtended.deleteExchanges"><code class="name flex">
<span>def <span class="ident">deleteExchanges</span></span>(<span>self, name, single=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove matching exchanges</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteExchanges(self, name, single=True):
    &#39;&#39;&#39; Remove matching exchanges &#39;&#39;&#39;
    exchs = self.getExchange(name, single=single)
    if not isinstance(exchs, list):
        exchs = [exchs]
    if len(exchs) == 0:
        raise Exception(&#34;No exchange found for &#39;%s&#39;&#34; % name)
    for ex in exchs:
        ex.delete()
        ex.save()
    self.save()</code></pre>
</details>
</dd>
<dt id="lca_algebraic.helpers.ActivityExtended.exchangesNp"><code class="name flex">
<span>def <span class="ident">exchangesNp</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>List of exchange, except production (output) one.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exchangesNp(self):
    &#34;&#34;&#34; List of exchange, except production (output) one.&#34;&#34;&#34;
    for exch in self.exchanges():
        if exch[&#39;input&#39;] != exch[&#39;output&#39;]:
            yield exch</code></pre>
</details>
</dd>
<dt id="lca_algebraic.helpers.ActivityExtended.getAmount"><code class="name flex">
<span>def <span class="ident">getAmount</span></span>(<span>self, *args, sum=False, **kargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the amount of one or several exchanges, selected by name or input. See #getExchange()</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAmount(self, *args, sum=False, **kargs):
    &#34;&#34;&#34;
    Get the amount of one or several exchanges, selected by name or input. See #getExchange()
    &#34;&#34;&#34;
    exchs = self.getExchange(*args, single=not sum, **kargs)
    if sum:
        res = 0
        if len(exchs) == 0:
            raise Exception(&#34;No exchange found&#34;)
        for exch in exchs:
            res += _getAmountOrFormula(exch)
        return res
    else:
        return _getAmountOrFormula(exchs)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.helpers.ActivityExtended.getExchange"><code class="name flex">
<span>def <span class="ident">getExchange</span></span>(<span>self, name=None, input=None, single=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Get exchange by name or input</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>name</code> of <code>the</code> <code>exchange.</code> <code>Name</code> <code>can</code> <code>be</code> <code>suffixed</code> <code>with</code> <code>'</code>#<code>LOCATION'</code> <code>to</code> <code>distinguish</code> <code>several</code> <code>exchanges</code> <code>with</code> <code>same</code> <code>name.</code>
<code>It</code> <code>can</code> <code>also</code> <code>be</code> <code>suffised</code> <code>by</code> <code>'</code>*<code>'</code> <code>to</code> <code>match</code> <code>an</code> <code>exchange</code> <code>starting</code> <code>with</code> <code>this</code> <code>name.</code> <code>Location</code> <code>can</code> <code>be</code> <code>a</code> <code>negative</code> <code>match</code> <code>'</code>!<code>'</code></dt>
<dd>Exampple : "Wood*#!RoW" matches any exchange with name
containing Wood, and location not "RoW"</dd>
</dl>
<p>single :True if a single match is expected. Otherwize, a list of result is returned</p>
<h2 id="returns">Returns</h2>
<pre><code>Single exchange or list of exchanges (if _single is False or "name" contains a '*')
raise Exception if not matching exchange found
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getExchange(self, name=None, input=None, single=True):
    &#34;&#34;&#34;Get exchange by name or input

    Parameters
    ----------
    name : name of the exchange. Name can be suffixed with &#39;#LOCATION&#39; to distinguish several exchanges with same name. \
        It can also be suffised by &#39;*&#39; to match an exchange starting with this name. Location can be a negative match &#39;!&#39;
        Exampple : &#34;Wood*#!RoW&#34; matches any exchange with name  containing Wood, and location not &#34;RoW&#34;

    single :True if a single match is expected. Otherwize, a list of result is returned

    Returns
    -------
        Single exchange or list of exchanges (if _single is False or &#34;name&#34; contains a &#39;*&#39;)
        raise Exception if not matching exchange found
    &#34;&#34;&#34;

    def single_match(name, exch):

        # Name can be &#34;Elecricity#RER&#34;
        if &#34;#&#34; in name:
            name, loc = name.split(&#34;#&#34;)
            negative = False
            if loc.startswith(&#34;!&#34;):
                negative = True
                loc = loc[1:]
            act = getActByCode(*exch[&#39;input&#39;])

            if not &#39;location&#39; in act or (negative and act[&#39;location&#39;] == loc) or (
                    not negative and act[&#39;location&#39;] != loc):
                return False

        if &#39;*&#39; in name:
            name = name.replace(&#39;*&#39;, &#39;&#39;)
            return name in exch[&#39;name&#39;]
        else:
            return name == exch[&#39;name&#39;]

    def match(exch):
        if name:
            if isinstance(name, list):
                return any(single_match(iname, exch) for iname in name)
            else:
                return single_match(name, exch)

        if input:
            return input == exch[&#39;input&#39;]

    exchs = list(exch for exch in self.exchangesNp() if match(exch))
    if len(exchs) == 0:
        raise Exception(&#34;Found no exchange matching name : %s&#34; % name)

    if single and len(exchs) != 1:
        raise Exception(&#34;Expected 1 exchange with name &#39;%s&#39; found %d&#34; % (name, len(exchs)))
    if single:
        return exchs[0]
    else:
        return exchs</code></pre>
</details>
</dd>
<dt id="lca_algebraic.helpers.ActivityExtended.setOutputAmount"><code class="name flex">
<span>def <span class="ident">setOutputAmount</span></span>(<span>self, amount)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the amount for the single output exchange (1 by default)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setOutputAmount(self, amount):
    &#39;&#39;&#39;Set the amount for the single output exchange (1 by default)&#39;&#39;&#39;
    self.addExchanges({self: amount})</code></pre>
</details>
</dd>
<dt id="lca_algebraic.helpers.ActivityExtended.substituteWithDefault"><code class="name flex">
<span>def <span class="ident">substituteWithDefault</span></span>(<span>self, exchange_name, switch_act, paramSwitch, amount=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Substitutes one exchange with a switch on other activities, or fallback to the current one as default (parameter set to None)
For this purpose, we create a new exchange referencing the activity switch, and we multiply current activity by '<param_name>_default',
making it null as soon as one enum value is set.</p>
<p>This is useful for changing electricty mix, leaving the default one if needed</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>act</code></strong> :&ensp;<code>Activity</code> <code>to</code> <code>update</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>exchange_name</code></strong> :&ensp;<code>Name</code> of <code>the</code> <code>exchange</code> <code>to</code> <code>update</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>switch_act</code></strong> :&ensp;<code>Activity</code> <code>to</code> <code>substitue</code> <code>as</code> <code>input</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>amount</code></strong> :&ensp;<code>Amount</code> of <code>the</code> <code>input</code> (<code>uses</code> <code>previous</code> <code>amount</code> <code>by</code> default)</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def substituteWithDefault(self, exchange_name: str, switch_act: Activity, paramSwitch: EnumParam, amount=None):

    &#34;&#34;&#34;Substitutes one exchange with a switch on other activities, or fallback to the current one as default (parameter set to None)
    For this purpose, we create a new exchange referencing the activity switch, and we multiply current activity by &#39;&lt;param_name&gt;_default&#39;,
    making it null as soon as one enum value is set.

    This is useful for changing electricty mix, leaving the default one if needed

    Parameters
    ----------
    act : Activity to update
    exchange_name : Name of the exchange to update
    switch_act : Activity to substitue as input
    amount : Amount of the input (uses previous amount by default)
    &#34;&#34;&#34;

    current_exch = self.getExchange(exchange_name)

    prev_amount = amount if amount else _getAmountOrFormula(current_exch)

    self.addExchanges({switch_act: prev_amount})
    self.updateExchanges({exchange_name: paramSwitch.symbol(None) * prev_amount})</code></pre>
</details>
</dd>
<dt id="lca_algebraic.helpers.ActivityExtended.updateExchanges"><code class="name flex">
<span>def <span class="ident">updateExchanges</span></span>(<span>self, updates={})</span>
</code></dt>
<dd>
<section class="desc"><p>Update existing exchanges, by name.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>updates</code></strong> :&ensp;<code>Dict</code> of <code>"</code>&lt;<code>exchange</code> <code>name</code>&gt;<code>"</code> =&gt; &lt;<code>new</code> <code>value</code>&gt;</dt>
<dd>
<p><exchange name> can be suffixed with '#LOCATION' to distinguish several exchanges with same name.
It can also be suffixed by '<em>' to match an exchange starting with this name. Location can be a negative match '!'
Exampple : "Wood</em>#!RoW" matches any exchange with name
containing Wood, and location not "RoW"</p>
<p><New Value>
: either single value (float or SympPy expression) for updating only amount, or activity for updating only input,
or dict of attributes, for updating both at once, or any other attribute.
The amount can reference the symbol 'old_amount' that will be replaced with the current amount of the exchange.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateExchanges(self, updates: Dict[str, any] = dict()):
    &#34;&#34;&#34;Update existing exchanges, by name.

    Parameters
    ----------
    updates : Dict of &#34;&lt;exchange name&gt;&#34; =&gt; &lt;new value&gt;

        &lt;exchange name&gt; can be suffixed with &#39;#LOCATION&#39; to distinguish several exchanges with same name. \
        It can also be suffixed by &#39;*&#39; to match an exchange starting with this name. Location can be a negative match &#39;!&#39;
        Exampple : &#34;Wood*#!RoW&#34; matches any exchange with name  containing Wood, and location not &#34;RoW&#34;

        &lt;New Value&gt;  : either single value (float or SympPy expression) for updating only amount, or activity for updating only input,
        or dict of attributes, for updating both at once, or any other attribute.
        The amount can reference the symbol &#39;old_amount&#39; that will be replaced with the current amount of the exchange.
    &#34;&#34;&#34;

    # Update exchanges
    for name, attrs in updates.items():

        exchs = self.getExchange(name, single=not &#39;*&#39; in name)
        if not isinstance(exchs, list):
            exchs = [exchs]
        for exch in exchs:

            if attrs is None:
                exch.delete()
                exch.save()
                continue

            # Single value ? =&gt; amount
            if not isinstance(attrs, dict):
                if isinstance(attrs, Activity):
                    attrs = dict(input=attrs)
                else:
                    attrs = dict(amount=attrs)

            if &#39;amount&#39; in attrs:
                attrs.update(_amountToFormula(attrs[&#39;amount&#39;], exch[&#39;amount&#39;]))

            exch.update(attrs)
            exch.save()

            # We have a formula now ? =&gt; register it to parametrized exchange
            if &#39;formula&#39; in attrs:
                bw.parameters.add_exchanges_to_group(DEFAULT_PARAM_GROUP, self)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lca_algebraic" href="index.html">lca_algebraic</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="lca_algebraic.helpers.ECOINVENT_DB_NAME" href="#lca_algebraic.helpers.ECOINVENT_DB_NAME">ECOINVENT_DB_NAME</a></code></li>
<li><code><a title="lca_algebraic.helpers.copyActivity" href="#lca_algebraic.helpers.copyActivity">copyActivity</a></code></li>
<li><code><a title="lca_algebraic.helpers.findActivity" href="#lca_algebraic.helpers.findActivity">findActivity</a></code></li>
<li><code><a title="lca_algebraic.helpers.findBioAct" href="#lca_algebraic.helpers.findBioAct">findBioAct</a></code></li>
<li><code><a title="lca_algebraic.helpers.findTechAct" href="#lca_algebraic.helpers.findTechAct">findTechAct</a></code></li>
<li><code><a title="lca_algebraic.helpers.getActByCode" href="#lca_algebraic.helpers.getActByCode">getActByCode</a></code></li>
<li><code><a title="lca_algebraic.helpers.newActivity" href="#lca_algebraic.helpers.newActivity">newActivity</a></code></li>
<li><code><a title="lca_algebraic.helpers.newInterpolatedAct" href="#lca_algebraic.helpers.newInterpolatedAct">newInterpolatedAct</a></code></li>
<li><code><a title="lca_algebraic.helpers.newSwitchAct" href="#lca_algebraic.helpers.newSwitchAct">newSwitchAct</a></code></li>
<li><code><a title="lca_algebraic.helpers.printAct" href="#lca_algebraic.helpers.printAct">printAct</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lca_algebraic.helpers.ActivityExtended" href="#lca_algebraic.helpers.ActivityExtended">ActivityExtended</a></code></h4>
<ul class="">
<li><code><a title="lca_algebraic.helpers.ActivityExtended.addExchanges" href="#lca_algebraic.helpers.ActivityExtended.addExchanges">addExchanges</a></code></li>
<li><code><a title="lca_algebraic.helpers.ActivityExtended.deleteExchanges" href="#lca_algebraic.helpers.ActivityExtended.deleteExchanges">deleteExchanges</a></code></li>
<li><code><a title="lca_algebraic.helpers.ActivityExtended.exchangesNp" href="#lca_algebraic.helpers.ActivityExtended.exchangesNp">exchangesNp</a></code></li>
<li><code><a title="lca_algebraic.helpers.ActivityExtended.getAmount" href="#lca_algebraic.helpers.ActivityExtended.getAmount">getAmount</a></code></li>
<li><code><a title="lca_algebraic.helpers.ActivityExtended.getExchange" href="#lca_algebraic.helpers.ActivityExtended.getExchange">getExchange</a></code></li>
<li><code><a title="lca_algebraic.helpers.ActivityExtended.setOutputAmount" href="#lca_algebraic.helpers.ActivityExtended.setOutputAmount">setOutputAmount</a></code></li>
<li><code><a title="lca_algebraic.helpers.ActivityExtended.substituteWithDefault" href="#lca_algebraic.helpers.ActivityExtended.substituteWithDefault">substituteWithDefault</a></code></li>
<li><code><a title="lca_algebraic.helpers.ActivityExtended.updateExchanges" href="#lca_algebraic.helpers.ActivityExtended.updateExchanges">updateExchanges</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>